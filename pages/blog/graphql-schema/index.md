<em>How we use a GraphQL schema to dramatically simplify syncing between back-end and front-end.</em>

<h2>A single source of truth for app data</h2>
Ropig is built with GraphQL. There are <a href="http://graphql.org/">plenty of goodies GraphQL has to offer</a>, but in this post, I want to go over one of our favorites: the schema.

A GraphQL schema <strong>describes your data</strong>. Using <a href="http://graphql.org/learn/schema/">GraphQL's fantastic type system</a>, you can clearly define the public API of your entire back-end. It looks like this:

```language-graphql
schema {
  query: RootQueryType
  mutation: RootMutationType
}

type RootQueryType {
  currentUser: CurrentUser
  billing: Billing
}

type RootMutationType {
  registerUser(email: String!, invitationToken: String, password: String!): CurrentUser
  registerCompany(name: String!): Company
  resetPassword(password: String!, resetPasswordToken: String!): CurrentUser
  login(email: String!, password: String!): CurrentUser
  logout: CurrentUser
  updateBilling(input: UpdateBillingInput!): Billing
}

type CurrentUser {
  id: ID
  authToken: String
  firstName: String
  lastName: String
  email: String
  mobile: String
  isOwner: Boolean
  company: Company
}

type Company {
  id: ID
  name: String
}

type Billing {
  trialDaysLeft: Int
  plan: BillingPlan
  card: Card
  nextPaymentDue: String
}

enum BillingPlan {
  FREE
  SOLO
  TEAM
}

type Card {
  lastFourDigits: String
  type: String
}
```

This means that with a schema <strong>you have a single contract between the back-end and front-end</strong>.

With just this simple schema, we know exactly what we can do with our app's API. For example, we can:

<ul>
 	<li>run <code>registerUser</code> on new user signup</li>
 	<li>run <code>logout</code> to log the user out</li>
 	<li>run <code>login</code> to log the user in</li>
 	<li>run <code>updateBilling</code> to let the user subscribe using a credit card</li>
 	<li>query <code>billing</code> to see what plan the user is on</li>
</ul>
This type of contract on top of a solid type system opens up some sweet possibilities...
<h2>Abstracting implementation</h2>
With a schema, we know what our public contract is for our API. It doesn't matter if <code>updateBilling</code> is <a href="https://ropig.com/blog/caching-stripe-data-complete-control-payment-subscriptions/">using Stripe</a> or Paypal under the hood for payment processing, or if the back-end language is Elixir or Java, or if user data is being stored in PostgreSQL or MongoDB. We have a clean public API and can change the implementation details on back-end or front-end without breaking the rest of the system.
<h2>Working in tandem</h2>
A schema also lets you work quickly across the stack. For example, let's say we now want to add a feature where we can show an entire team (every user in a company). The front-end or back-end could propose some schema changes like:

```language-graphql
extend type RootQueryType {
  team: [User]
}

type User {
  id: ID
  firstName: String
  lastName: String
  email: String
  mobile: String
  isOwner: Boolean
  company: Company
}
```

And now both the back-end and front-end can proceed with their implementations without holding each other back. Then, when implementations are ready, it should "just work" as long as the schema is respected. We have been doing this on Ropig for a long time and this workflow has truly just worked for us most of the time.

<h2>Generating the schema from the API</h2>
Instead of maintaining the schema file manually, you can have it automatically generated by your API. There are a few ways you can do this, but I recommend using <a href="https://github.com/graphcool/graphql-config">graphql-config</a> and <a href="https://github.com/graphcool/graphql-cli">graphql-cli</a>. Then you can use a <code>.graphqlconfig</code> like:

```language-graphql
{
  "schemaPath": "schema.graphql",
  "extensions": {
    "endpoints": {
      "dev": "http://localhost:4000/api"
    }
  }
}
```

Next, just run <code>graphql get-schema</code> to update your <code>schema.graphql</code> file with the latest changes in the API.

<h2>Generating types for other type systems from the schema</h2>
Having a schema lets you automate other things from the type system as well. For example, you can generate types for other type systems from it (for TypeScript, Flow, Swift, Scala etc.) using something like <a href="https://github.com/apollographql/apollo-codegen">apollo-codegen</a>. For example, Ropig uses Flow so we can run:

<code>apollo-codegen generate <span class="keyword operator shell">\*_</span>/<span class="keyword operator shell">_</span>.graphql --target flow --output schema.flow.js</code>

to generate Flow types automatically from schema types. It can use a <code>.graphqlconfig</code> to locate your schema just like we did in the previous section.

<h2>Generating example data from the schema</h2>
With a schema, you can automatically generate example data that can be used for building out the front-end before the real back-end is ready or for testing. The usage depends on what tools and languages you are using. For example, on Ropig we are using Apollo with React on the front-end, so we can use <a href="https://www.npmjs.com/package/apollo-link-schema">apollo-link-schema</a> for this. We just pass it mock functions for certain schema types that look like this (in JavaScript, with <a href="https://www.npmjs.com/package/faker">faker</a> for example):

```language-graphql
import faker from 'faker'
import { MockList } from 'graphql-tools'

const mocks = {
  String: () => faker.lorem.text(),

  ID: () => faker.random.uuid(),

  CurrentUser: () => ({
    authToken: () => faker.random.uuid(),
    firstName: () => faker.name.firstName(),
    lastName: () => faker.name.lastName(),
    email: () => faker.internet.email(),
    mobile: () => faker.phone.phoneNumber(),
    isOwner: () => faker.random.boolean(),
  }),

  User: () => ({
    firstName: () => faker.name.firstName(),
    lastName: () => faker.name.lastName(),
    email: () => faker.internet.email(),
    mobile: () => faker.phone.phoneNumber(),
  }),

  Company: () => ({
    name: () => faker.company.companyName(),
  }),

  RootQueryType: () => ({
    team: () => new MockList([0, 30]),
  }),
}

export default mocks
```

Then the API is wrapped to use these mocked functions depending on the environment. So, for example, in a test or dev environment, we could get back example data to use in building out new features (before the real back-end is ready) or in tests!

<h2>Conclusion</h2>
GraphQL has a lot going for it. This is cool stuff. But especially having a schema as a public contract is very helpful. I bet we have just scratched the surface of what is possible. I'm excited about the future of GraphQL!
